We need a schema that can support our major use cases and is not too horrible.

PRIMARY USE CASE: BUY OR NOT?

The primary use case is deciding whether or not to buy.

A concrete example; you subscribe to the HRC Buyer's Guide, and you want to know whether Perrier is an ethical purchase. Perrier is listed as a brand belonging to Nestle in the HRC Buyer's Guide:

    http://www.hrc.org/apps/buyersguide/profile.php?orgid=1473

Nestle gets 25 out of a possible 100 points, and is in HRC's "red" category. So we show the user something on a red background with a standard icon (maybe thumbs down, a stop sign, a red X, etc) that looks like this:

25 out of 100 <--- big text
Human Rights Campaign <---- smaller text

There's a lot of information we can easily gather that we left out:
- this is a rating of Nestle, not the Perrier brand per se
- it comes from the HRC "Buyer's Guide" and not some other guide from HRC
- the long-form description of what red means  ("Businesses/brands that receive our lowest workplace equality scores.")
- how the score was calculated

My thinking is that if users care about the details, they can click through to another page to find out more. In the beginning, that other page can simply be the page on HRC's site (the URL above).

HRC isn't the only guide that uses red/yellow/green. It seems to be the closest thing to a de-facto standard among guides, and we're going to adopt it as our standard; guides can have any sort of rating system they want, but it'll all boil down to red/yellow/green and a short text description.

The text description can be anything that cues people as to what's going on. If you were also subscribed to, say Baby Milk Action's Nestle Boycott:

    http://babymilkaction.org/nestlefree

we could show something like (also in red):

Boycott Nestle  <--- big
Baby Milk Action  <--- small

It would be helpful to have the option of displaying a caveat. For example, the EDF Seafood Selector lists U.S. Albacore Tuna as good for the oceans, but containing moderate levels of mercury. If we just show green, it looks like an unconditional endorsement. Something like:

BEST*  <------ big
* MODERATE contaminants: mercury  <--- small
Environmental Defense Fund  <---- small


OTHER USE CASES

Some other use cases we need to think about, in roughly decreasing priority:

- Buying Guide landing page
- A-Z catalog by brand, company, etc.
- Free-text search
- Subscription management
- Prioritizing one guide over another
- Sharing on Facebook/Twitter/etc.
- Local filters (filter out products that aren't available to me)
- Local search (search for relevant businesses within a bounding box)
- Starting and managing a campaign
- Buying guide details (how scores were calculated, etc.)


REPRESENTING DATA

I'm leaning towards using a slightly bastardized compact JSON form of the microdata schemas at schema.org. schema.org's stuff seems pretty well-thought-out, microdata is the hot new semantic web format, and JSON because, well, I'm using a JSON data store. In theory, if my service takes off, sites that want to run campaigns could simply annotate their HTML properly and never have to touch the API.

If you wanted to represent a hotel on from the UNITE HERE Union Hotel Guide (http://www.hotelworkersrising.org/HotelGuide/results.php):

Congress Plaza Hotel - ON STRIKE
520 S. Michigan
Chicago, IL 60605
Phone: 312-212-8192

You'd use the Hotel schema (http://schema.org/Hotel). It'd look something like this:

{
    "type": "Hotel",
    "name": "Congress Plaza Hotel",
    "address": {
        "streetAdress": "520 S. Michigan",
	"addressLocality": "Chicago",
	"addressRegion": "CA",
	"postalCode": "60605",
	"telephone": "312-212-8192",
    },
}

If our parser were extra-helpful, it could infer address.addressCountry = "US" as well (this guide only covers US and Canada hotels).

As far as I can tell, the most widely adopted microdata-as-JSON format is the one here: http://foolip.org/microdatajs/live/, which would have us doing something like this for the hotel:

{
    "type": ["Hotel"],
    "properties": {
        "name": ["Congress Plaza Hotel"],
	"address": [
            "type": ["PostalAddress"],
	    "properties": {
	        "streetAddress": ["520 S. Michigan"],
		...
	    }
        }
    }
}

Why is everything in an array? Because every field can have multiple values, since there's nothing to stop people making multiple HTML tags that have the same itemprop value. This is sometimes useful (for example http://schema.org/Organization has a "brand" field which is probably usually going to refer to multiple brands), but usually it just seems unnecessarily verbose. So I'm going to make the brackets optional if a property has a single value. JavaScript is not the greatest at telling us whether an object is an array or something else, but it can do it.

I'm also okay with "type" being a special property. In theory, you CAN do this with HTML microdata, but you shouldn't:

<div itemtype="foo" itemscope>
    <span itemprop="type">bar</span>
</div>

Finally, I left out the type of the address. http://schema.org/Hotel says address can only ever be a PostalAddress, so we can infer it.

Anyways, our Hotel would be contained in some sort of BuyingRecommendation schema, so, something like:

{
    "type": "Thing/BuyingRecommendationV1,
    "buy": {
        "type": "Enumeration/Judgment/Bad",
	"name": "On Strike",
    },
    "target": {
        "type": "Hotel",
	...
    }
}

The "Thing/..." type indicates that we extended an existing schema, see http://schema.org/docs/extension.html. And it's "...V1" because I'm *sure* I'm not going to get this right the first time.

We also define a custom Enumeration subclass corresponding to our red/yellow/green color system. Possible values are Enumeration/Judgment/Bad, Enumeration/Judgment/Warning, and Enumeration/Judgment/Good

This goes inside some sort of BuyingGuide object, which extends http://schema.org/CreativeWork:

{
    "type": "CreativeWork/BuyingGuideV1",
    "isBasedOnUrl": "http://www.hotelworkersrising.org/HotelGuide/results.php",
    "name": "Union Hotel Guide",
    "author": {
        "type": "Organization",
	"name": "UNITE HERE",
    },
    "recommendation": [
        {
	    "buy": {
                "type": "Enumeration/Judgment/Bad",
	        "name": "On Strike",
    	    },
	    "target": {
     	        "type": "Hotel",
	        ...
            },
        },
	...
    ],
}

And there we go, a buying guide schema. Note that even though we will probably have multiple recommendations, we named the field "recommendation" not "recommendations" (all fields are implicitly plural), and that we left out the type of recommendation, because BuyingGuideV1.recommendation is define to only ever contain BuyingRecommendationV1s.

FUTURE WORK: TABULAR DATA

Most buying guides include some sort of data that begs to be displayed in a table (if it isn't already).

Sometimes it's information about how scores were calculated. For example, the Ciornucopia Institute Organic Egg Scorecard (http://www.cornucopia.org/organic-egg-scorecard/) has a "total score" (on a scale of 0-2200), which is then used to compute a "Rating" (on a scale of 1-5), which then has a corresponding name (e.g. 5 -- Exemplary), except that 1 can either mean "Ethically Deficient" or "Private Label". In theory, we could represent all of this information in a machine-readable format; the question is, what do we do with it?

Sometime's it's extra information that might also be useful to the consumer. Forexample, seafood.edf.org has information about contaminants and how many servings of the fish you should consume each month, and whether it contains omega 3s.

For now, let's just shove extra stuff in a field called "extra" (in either the BuyingGuide or BuyingRecommendation objects).
